# Smidgen - Architecture & Design Vision

## Project Overview

Smidgen is a high-performance library for generating compact, sortable, human-readable identifiers using Crockford Base32 encoding.
The library is designed for .NET 9 with C# 13, emphasizing performance, safety, and a minimal public API surface.
However, we will want to target .NET 8 as the minimum supported framework version to reach a wider audience.
Potentially we could multi-target .NET 8 and .NET 10 if there are any APIs that are only available in .NET 10 that we want to use.
In all cases, we will use the latest C# language features available in C# 13 since the build agent will support the .NET 10 SDK.

## Core Components (Current, subject to change)

### 1. **IdGenerator** (Public)
Generates 64-bit unsigned integer identifiers that combine:
- **Time component** (48 bits) - milliseconds since Unix epoch
- **Entropy component** (16 bits) - random value
- **Monotonic guarantee** - ensures IDs are always increasing, even in concurrent scenarios

### 2. **IdFormatter** (Public)
Converts 64-bit identifiers to/from human-readable formatted strings:
- Uses customizable format templates with placeholder characters (default: `#`)
- Example: `"PRE-####-####-SUF"` ? `"PRE-ABCD-1234-SUF"`
- Supports up to 13 placeholders (65 bits > 64 bits of ulong)

### 3. **CrockfordEncoding** (Internal)
Low-level Base32 encoding/decoding optimized specifically for IdFormatter usage:
- Encodes ulong values to Crockford Base32 ASCII bytes
- Decodes Base32 bytes back to ulong
- Handles confusable characters (O?0, I?1, L?1) Those chars are never used in encoding and excluded by the
  Crockford Base32 alphabet, but they are allowed when decoding.
- Case-insensitive decoding

## Design Principles

### Performance First
- **Zero-allocation hot paths** - Use `Span<T>` and `stackalloc` wherever possible
- **Aggressive inlining** - Hot path methods marked with `[MethodImpl(MethodImplOptions.AggressiveInlining)]`
- **Exception throwing separated** - Mark with `[MethodImpl(MethodImplOptions.NoInlining)]` to keep hot paths small
- **Lookup tables over switch expressions** - Static readonly arrays for O(1) operations
- **Hardware intrinsics** - Use `BitOperations.LeadingZeroCount`, `SearchValues<T>` for SIMD
- **Trust internal callers** - Remove defensive checks in internal APIs

### Monontonically increasing Identifiers
Whether the caller wants to use the underlying integer representation or the formatted string representation,
identifiers generated by IdGenerator will always be monotonically increasing, sortable,
and suitable for database indexing without risk of fragmentation.

### Minimal Public API
- **Hide implementation details** - CrockfordEncoding is `internal`, only accessed via IdFormatter
- **Flexibility to evolve** - Internal APIs can change without breaking public contracts
- **Clear separation** - Public types (IdGenerator, IdFormatter) vs internal utilities

### Robustness at Boundaries
- **Validate user input** - All Parse/TryParse methods validate input thoroughly
- **Trust internal usage** - Skip validation when called from trusted internal code
- **Fail fast with clear messages** - Provide helpful error messages for invalid input. Introduce a common exception type if needed.

### Modern .NET Patterns
- **Use latest BCL features** - `ArgumentOutOfRangeException.ThrowIfZero`, `SearchValues<T>`
- **Readonly structs** - IdFormatter is a `readonly struct` for efficiency
- **Span-based APIs** - Accept `ReadOnlySpan<char>` for zero-copy parsing
- **String.Create pattern** - Efficient string building without intermediate allocations
- switch expressions and pattern matching where appropriate

### Code style
- Follow .editorconfig conventions
- keep namespace sections minimal and move any common usings to global usings
- Never use braces for single-line blocks
- public API members documented with XML comments

## Future Vision
When the functionality described below is implemented, this section should be updated to reflect the new architecture.

### IdGenerator Enhancements
Split the generation of an identifier from the responsibility of monotonic incrementation.
- Introduce a new `GeneratorSettings` type - generates Id elements and informs how wide they are
- `IdGenerator` should now wrap an `GeneratorSettings` instance and ensures monotonicity
- Tests can provide `GeneratorSettings` instances with appropriate functions to control time and entropy for deterministic testing
- Preset `GeneratorSettings` implementations
    - SmallId: 48 bits time (ms since epoch) + 16 bits entropy (random)
    - Id80: 48 bits time + 32 bits entropy
    - Id96: 56 bits time (microseconds since epoch) + 40 bits entropy
    - BigId: 64 bits time (ticks since epoch) + 64 bits entropy

Suggested API (verify with user if AI proposes changes for usability or performance improvements):

```csharp
// should validate, use constructor to enforce invariants. As consumer can create custom instances, contructor is public
public sealed class GeneratorSettings
{
    public byte TimeBits { get; } // Number of bits allocated to time
    public byte EntropyBits { get; } // Number of bits allocated to entropy
    public Func<ulong> GetTimeElement { get; } // Function to get current time element
    public Func<ulong> GetEntropyElement { get; } // Function to get entropy element
    public Func<ulong> IncrementFunction { get; } // Function to obtain increment value when needed
    public Func<ulong,DateTime> GetDateTimeFromId { get; } // Function to extract DateTime from generated ID

    public static readonly GeneratorSettings SmallId { get; } // 48 bits time + 16 bits entropy
    public static readonly GeneratorSettings Id80 { get; } // 48 bits time + 32 bits entropy
    public static readonly GeneratorSettings Id96 { get; } // 56 bits time + 40 bits entropy
    public static readonly GeneratorSettings BigId { get; } // 64 bits time + 64 bits entropy
}

public sealed class IdGenerator
{
    private UInt128 _lastId;

    // non-monotonic ID generation based on settings
    private UInt128 GenerateId();

    public IdGenerator(GeneratorSettings settings);

    // Generates monotonic ID. Calls GenerateId() internally.
    // Implementation pattern:
    public UInt128 Next()
    {
        while (true)
        {
            UInt128 rawId = GenerateId();
            UInt128 lastId = _lastId;
            
            UInt128 nextId = rawId > lastId 
                ? rawId 
                : lastId + _settings.IncrementFunction();
            
            if (Interlocked.CompareExchange(ref _lastId, nextId, lastId) == lastId)
                return nextId;
        }
    }
}
```
### GeneratorSettings Details
- `TimeBits` and `EntropyBits` define how many bits are allocated to each element.
- Their sum must be <= 128. The maximum size for both of these is 64 bits.
- The minimum size for a useful time element should be 32 bits (consumer might choose to count seconds instead of milliseconds for example).
- The minimum size for a useful entropy element should be 16 bits. It should be a multiple of 8 bits for byte alignment.
- Since the max size of these elements is 64 bits, a ulong is sufficient to hold the value returned by `GetTimeElement` and `GetEntropyElement`.
- `IdGenerator` will combine these two elements into a `UInt128` value by shifting the time element left by the size of the entropy element,
then binary ORing with the entropy element.
- If `IdGenerator` needs to get the time from the last generated ID, it can extract it by shifting right by the size of the entropy element
  and calling `GetDateTimeFromId` to convert to a `DateTime`.

### Helper Time functions
The Preset `GeneratorSettings` can use these helper functions to get time elements based on different epochs and resolutions.
The class is internal since it is only used by `GeneratorSettings` implementations.
A consumer that wants to customise time elements is responsible for implementing their own functions.

```csharp
internal static class TimeElements
{
    public static ulong MillisecondsSinceUnixEpoch() { ... }
    public static ulong MicrosecondsSinceUnixEpoch() { ... }
    public static ulong TicksSinceUnixEpoch() { ... }

    public static DateTime DateTimeFromMillisecondsSinceUnixEpoch(ulong timeValue) { ... }
    public static DateTime DateTimeFromMicrosecondsSinceUnixEpoch(ulong timeValue) { ... }
    public static DateTime DateTimeFromTicksSinceUnixEpoch(ulong timeValue) { ... }
}
```

### Random Entropy functions
- The Preset `GeneratorSettings` can use these helper functions to get entropy elements of varying widths.
- Randomness should be sourced from `RandomNumberGenerator.Fill(Span<byte>)` as it provides cryptographically secure randomness.
- However, for peformance reasons, we probably want a buffer of random bytes that is refilled as needed.
- A suggested approach is to use a byte buffer (customisable size, but 4096 default).
- The access to this buffer should be thread-safe. We want to avoid locking on every access.
- We use Interlocked.Add to get the next index in the buffer atomically.
- We can use a lock during refills to ensure only one thread refills the buffer at a time.
- Refill happens when the next index exceeds the buffer size. After refill, the index is reset to 0.
- An observation is that we probably want factors of 8 bits for entropy widths (16, 32, 40, 48, 64) to simplify byte alignment
when accessing the random byte buffer.

Suggested API
```csharp
internal static class EntropyElements
{
    // Default buffer size: 4096 bytes
    public static byte GetIncrementByte() { ... } // Returns next byte or 37, whichever is larger
    public static ushort Get16Bits() { ... }  // Returns value with top bit = 0 (15 bits effective)
    public static uint Get32Bits() { ... }    // Returns value with top bit = 0 (31 bits effective)
    public static ulong Get40Bits() { ... }   // Returns value with top bit = 0 (39 bits effective)
    public static ulong Get48Bits() { ... }   // Returns value with top bit = 0 (47 bits effective)
    public static ulong Get64Bits() { ... }   // Returns value with top bit = 0 (63 bits effective)
}

```

### Increment functions
- The purpose of the increment function is to provide a way to get the next identifier when the generated raw identifier
is less than or equal to the last generated identifier.
- We want to avoid incrementing by 1. Ideally, we want to increment by a random amount,
  but a smaller range of possible random values than the full entropy width.
- When the random element is large enough, incrementing the identifier can cause the time element to roll over.
- To counter that, the entropy element should leave some headroom to allow for some increments without rolling over the time element.
- Therefore, we will reserve the top bit of the entropy element as a "carry" bit. 
  When the entropy value is obtained, we ensure that bit is set to 0. The width `EntropyBits` includes that carry bit.
- The random increment function can use the same shared random buffer to get a random value in the range [37, 255].
- MinElement is set to 37 as the first prime number larger than 32 (to avoid patterns when incrementing).

### IdFormatter Enhancements
Change parameters from ulong to UInt128 to support formatting and parsing of variable-width identifiers.

### CrockfordEncoding Enhancements
Change parameters from ulong to UInt128 to support encoding and decoding of variable-width identifiers.
- Existing code that works with the constant 13 to represent the max length of a ulong in Crockford Base32
  will need to be updated to 26 to represent the max length of a UInt128 in Crockford Base32.

## Code Organization

### Source Structure (current)
```
src/Smidgen/
    IdGenerator.cs       (Public) - Monotonic ID generation
    IdFormatter.cs       (Public) - Format/Parse with templates
    CrockfordEncoding.cs (Internal) - Low-level encoding/decoding
```

### Test Structure (current)
```
tests/Smidgen.Tests/
    IdGeneratorTests.cs
    IdFormatterTests.cs
    CrockfordEncodingTests.cs (tests internal via InternalsVisibleTo)
```

### Future structure considerations
Simple - just keep everything in a flat structure for now.

## Testing Philosophy
### Controlling determinism
- Use `GeneratorSettings` to control determinism in tests.

### Test Coverage Strategy
- **Public API tests** - Comprehensive tests for IdGenerator and IdFormatter
- **Internal API tests** - Focused tests for CrockfordEncoding behavior
- **Integration tests** - Round-trip testing (Format ? Parse ? verify)
- **Edge cases** - Zero values, max values, empty inputs, invalid characters
- **Concurrency tests** - IdGenerator thread-safety validation

### Test Style Guidelines
- **Clear test names** - `MethodName_Scenario_ExpectedBehavior`
- **Theory over Fact** - Use `[Theory]` with `[InlineData]` for parameterized tests
- Can use xUnit.v3 features, for example TheoryData<T1, T2> and Matrix data sources.
- **Arrange-Act-Assert** - Clear separation of test phases
- **Consistency checks** - Verify encode/decode round-trips
- **Performance tests** - Large iteration counts (10,000+) for hot paths

## Performance Targets

### Benchmarks (Target)
- **IdGenerator.Generate()** - < 100ns per call
- **IdFormatter.Format()** - < 200ns per call
- **IdFormatter.Parse()** - < 300ns per call
- **Zero allocations** - Hot paths should not allocate (except final string result)

### Optimization Techniques in Use
1. Static readonly lookup tables (EncodeTable, DecodeTable)
2. SearchValues<byte> for SIMD-optimized validation
3. BitOperations.LeadingZeroCount for length calculation
4. Aggressive inlining on hot paths
5. NoInlining on cold paths (exception throwing)
6. Stackalloc for temporary buffers
7. String.Create for zero-copy string building
8. Direct array indexing (no bounds checks in release)

## API Evolution Guidelines
Nothing is published yet, so there is no concerns with breaking changes.

## Security & Validation

### Input Validation Rules
- **Public methods** - Validate all user input thoroughly
- **Internal methods** - Trust caller, skip validation for performance
- **Parse methods** - Validate format, length, character set
- **Constructors** - Validate templates, placeholder counts

### Attack Surface Minimization
- **No reflection** - All code is statically analyzable
- **No dynamic code generation** - No eval, no compilation
- **Bounded operations** - Max 13 placeholders, max 64-bit values
- **Clear error messages** - Help users without exposing internals

## Documentation Standards

### XML Documentation
- ? All public types, methods, properties
- ? Use `<summary>`, `<remarks>`, `<param>`, `<returns>`, `<exception>`
- ? Provide examples in remarks when helpful
- ? Document performance characteristics when relevant

### Code Comments
- Explain "why" not "what" (code shows what)
- Document non-obvious optimizations
- Mark future extension points
- Reference specifications (e.g., Crockford Base32)

## Contributor Guidelines

### When Adding Features
1. Update this document with design decisions
2. Add comprehensive tests (aim for >95% coverage)
3. Run benchmarks to verify no performance regressions
4. Update XML documentation
5. Consider backward compatibility

### When Optimizing
1. Profile first - don't guess at bottlenecks
2. Measure before and after with BenchmarkDotNet
3. Document the optimization technique
4. Ensure tests still pass
5. Verify allocations haven't increased

### Code Review Checklist
- [ ] Tests added/updated
- [ ] XML documentation complete
- [ ] No new allocations in hot paths
- [ ] Follows existing code style
- [ ] Backward compatible (or version bump justified)
- [ ] Performance regression checked

---

**Last Updated**: 2025-01-XX  
**Target .NET Version**: .NET 9.0  
**C# Language Version**: 13.0
